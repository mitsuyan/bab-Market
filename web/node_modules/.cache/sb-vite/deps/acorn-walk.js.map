{
  "version": 3,
  "sources": ["../../../acorn-walk/dist/walk.mjs"],
  "sourcesContent": ["// AST walker module for Mozilla Parser API compatible trees\r\n\r\n// A simple walk is one where you simply specify callbacks to be\r\n// called on specific nodes. The last two arguments are optional. A\r\n// simple use would be\r\n//\r\n//     walk.simple(myTree, {\r\n//         Expression: function(node) { ... }\r\n//     });\r\n//\r\n// to do something with all expressions. All Parser API node types\r\n// can be used to identify node types, as well as Expression and\r\n// Statement, which denote categories of nodes.\r\n//\r\n// The base argument can be used to pass a custom (recursive)\r\n// walker, and state can be used to give this walked an initial\r\n// state.\r\n\r\nfunction simple(node, visitors, baseVisitor, state, override) {\r\n  if (!baseVisitor) { baseVisitor = base\r\n  ; }(function c(node, st, override) {\r\n    var type = override || node.type, found = visitors[type];\r\n    baseVisitor[type](node, st, c);\r\n    if (found) { found(node, st); }\r\n  })(node, state, override);\r\n}\r\n\r\n// An ancestor walk keeps an array of ancestor nodes (including the\r\n// current node) and passes them to the callback as third parameter\r\n// (and also as state parameter when no other state is present).\r\nfunction ancestor(node, visitors, baseVisitor, state, override) {\r\n  var ancestors = [];\r\n  if (!baseVisitor) { baseVisitor = base\r\n  ; }(function c(node, st, override) {\r\n    var type = override || node.type, found = visitors[type];\r\n    var isNew = node !== ancestors[ancestors.length - 1];\r\n    if (isNew) { ancestors.push(node); }\r\n    baseVisitor[type](node, st, c);\r\n    if (found) { found(node, st || ancestors, ancestors); }\r\n    if (isNew) { ancestors.pop(); }\r\n  })(node, state, override);\r\n}\r\n\r\n// A recursive walk is one where your functions override the default\r\n// walkers. They can modify and replace the state parameter that's\r\n// threaded through the walk, and can opt how and whether to walk\r\n// their child nodes (by calling their third argument on these\r\n// nodes).\r\nfunction recursive(node, state, funcs, baseVisitor, override) {\r\n  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor\r\n  ;(function c(node, st, override) {\r\n    visitor[override || node.type](node, st, c);\r\n  })(node, state, override);\r\n}\r\n\r\nfunction makeTest(test) {\r\n  if (typeof test === \"string\")\r\n    { return function (type) { return type === test; } }\r\n  else if (!test)\r\n    { return function () { return true; } }\r\n  else\r\n    { return test }\r\n}\r\n\r\nvar Found = function Found(node, state) { this.node = node; this.state = state; };\r\n\r\n// A full walk triggers the callback on each node\r\nfunction full(node, callback, baseVisitor, state, override) {\r\n  if (!baseVisitor) { baseVisitor = base; }\r\n  var last\r\n  ;(function c(node, st, override) {\r\n    var type = override || node.type;\r\n    baseVisitor[type](node, st, c);\r\n    if (last !== node) {\r\n      callback(node, st, type);\r\n      last = node;\r\n    }\r\n  })(node, state, override);\r\n}\r\n\r\n// An fullAncestor walk is like an ancestor walk, but triggers\r\n// the callback on each node\r\nfunction fullAncestor(node, callback, baseVisitor, state) {\r\n  if (!baseVisitor) { baseVisitor = base; }\r\n  var ancestors = [], last\r\n  ;(function c(node, st, override) {\r\n    var type = override || node.type;\r\n    var isNew = node !== ancestors[ancestors.length - 1];\r\n    if (isNew) { ancestors.push(node); }\r\n    baseVisitor[type](node, st, c);\r\n    if (last !== node) {\r\n      callback(node, st || ancestors, ancestors, type);\r\n      last = node;\r\n    }\r\n    if (isNew) { ancestors.pop(); }\r\n  })(node, state);\r\n}\r\n\r\n// Find a node with a given start, end, and type (all are optional,\r\n// null can be used as wildcard). Returns a {node, state} object, or\r\n// undefined when it doesn't find a matching node.\r\nfunction findNodeAt(node, start, end, test, baseVisitor, state) {\r\n  if (!baseVisitor) { baseVisitor = base; }\r\n  test = makeTest(test);\r\n  try {\r\n    (function c(node, st, override) {\r\n      var type = override || node.type;\r\n      if ((start == null || node.start <= start) &&\r\n          (end == null || node.end >= end))\r\n        { baseVisitor[type](node, st, c); }\r\n      if ((start == null || node.start === start) &&\r\n          (end == null || node.end === end) &&\r\n          test(type, node))\r\n        { throw new Found(node, st) }\r\n    })(node, state);\r\n  } catch (e) {\r\n    if (e instanceof Found) { return e }\r\n    throw e\r\n  }\r\n}\r\n\r\n// Find the innermost node of a given type that contains the given\r\n// position. Interface similar to findNodeAt.\r\nfunction findNodeAround(node, pos, test, baseVisitor, state) {\r\n  test = makeTest(test);\r\n  if (!baseVisitor) { baseVisitor = base; }\r\n  try {\r\n    (function c(node, st, override) {\r\n      var type = override || node.type;\r\n      if (node.start > pos || node.end < pos) { return }\r\n      baseVisitor[type](node, st, c);\r\n      if (test(type, node)) { throw new Found(node, st) }\r\n    })(node, state);\r\n  } catch (e) {\r\n    if (e instanceof Found) { return e }\r\n    throw e\r\n  }\r\n}\r\n\r\n// Find the outermost matching node after a given position.\r\nfunction findNodeAfter(node, pos, test, baseVisitor, state) {\r\n  test = makeTest(test);\r\n  if (!baseVisitor) { baseVisitor = base; }\r\n  try {\r\n    (function c(node, st, override) {\r\n      if (node.end < pos) { return }\r\n      var type = override || node.type;\r\n      if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\r\n      baseVisitor[type](node, st, c);\r\n    })(node, state);\r\n  } catch (e) {\r\n    if (e instanceof Found) { return e }\r\n    throw e\r\n  }\r\n}\r\n\r\n// Find the outermost matching node before a given position.\r\nfunction findNodeBefore(node, pos, test, baseVisitor, state) {\r\n  test = makeTest(test);\r\n  if (!baseVisitor) { baseVisitor = base; }\r\n  var max\r\n  ;(function c(node, st, override) {\r\n    if (node.start > pos) { return }\r\n    var type = override || node.type;\r\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\r\n      { max = new Found(node, st); }\r\n    baseVisitor[type](node, st, c);\r\n  })(node, state);\r\n  return max\r\n}\r\n\r\n// Used to create a custom walker. Will fill in all missing node\r\n// type properties with the defaults.\r\nfunction make(funcs, baseVisitor) {\r\n  var visitor = Object.create(baseVisitor || base);\r\n  for (var type in funcs) { visitor[type] = funcs[type]; }\r\n  return visitor\r\n}\r\n\r\nfunction skipThrough(node, st, c) { c(node, st); }\r\nfunction ignore(_node, _st, _c) {}\r\n\r\n// Node walkers.\r\n\r\nvar base = {};\r\n\r\nbase.Program = base.BlockStatement = base.StaticBlock = function (node, st, c) {\r\n  for (var i = 0, list = node.body; i < list.length; i += 1)\r\n    {\r\n    var stmt = list[i];\r\n\r\n    c(stmt, st, \"Statement\");\r\n  }\r\n};\r\nbase.Statement = skipThrough;\r\nbase.EmptyStatement = ignore;\r\nbase.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression =\r\n  function (node, st, c) { return c(node.expression, st, \"Expression\"); };\r\nbase.IfStatement = function (node, st, c) {\r\n  c(node.test, st, \"Expression\");\r\n  c(node.consequent, st, \"Statement\");\r\n  if (node.alternate) { c(node.alternate, st, \"Statement\"); }\r\n};\r\nbase.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\r\nbase.BreakStatement = base.ContinueStatement = ignore;\r\nbase.WithStatement = function (node, st, c) {\r\n  c(node.object, st, \"Expression\");\r\n  c(node.body, st, \"Statement\");\r\n};\r\nbase.SwitchStatement = function (node, st, c) {\r\n  c(node.discriminant, st, \"Expression\");\r\n  for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\r\n    var cs = list$1[i$1];\r\n\r\n    if (cs.test) { c(cs.test, st, \"Expression\"); }\r\n    for (var i = 0, list = cs.consequent; i < list.length; i += 1)\r\n      {\r\n      var cons = list[i];\r\n\r\n      c(cons, st, \"Statement\");\r\n    }\r\n  }\r\n};\r\nbase.SwitchCase = function (node, st, c) {\r\n  if (node.test) { c(node.test, st, \"Expression\"); }\r\n  for (var i = 0, list = node.consequent; i < list.length; i += 1)\r\n    {\r\n    var cons = list[i];\r\n\r\n    c(cons, st, \"Statement\");\r\n  }\r\n};\r\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\r\n  if (node.argument) { c(node.argument, st, \"Expression\"); }\r\n};\r\nbase.ThrowStatement = base.SpreadElement =\r\n  function (node, st, c) { return c(node.argument, st, \"Expression\"); };\r\nbase.TryStatement = function (node, st, c) {\r\n  c(node.block, st, \"Statement\");\r\n  if (node.handler) { c(node.handler, st); }\r\n  if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\r\n};\r\nbase.CatchClause = function (node, st, c) {\r\n  if (node.param) { c(node.param, st, \"Pattern\"); }\r\n  c(node.body, st, \"Statement\");\r\n};\r\nbase.WhileStatement = base.DoWhileStatement = function (node, st, c) {\r\n  c(node.test, st, \"Expression\");\r\n  c(node.body, st, \"Statement\");\r\n};\r\nbase.ForStatement = function (node, st, c) {\r\n  if (node.init) { c(node.init, st, \"ForInit\"); }\r\n  if (node.test) { c(node.test, st, \"Expression\"); }\r\n  if (node.update) { c(node.update, st, \"Expression\"); }\r\n  c(node.body, st, \"Statement\");\r\n};\r\nbase.ForInStatement = base.ForOfStatement = function (node, st, c) {\r\n  c(node.left, st, \"ForInit\");\r\n  c(node.right, st, \"Expression\");\r\n  c(node.body, st, \"Statement\");\r\n};\r\nbase.ForInit = function (node, st, c) {\r\n  if (node.type === \"VariableDeclaration\") { c(node, st); }\r\n  else { c(node, st, \"Expression\"); }\r\n};\r\nbase.DebuggerStatement = ignore;\r\n\r\nbase.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\r\nbase.VariableDeclaration = function (node, st, c) {\r\n  for (var i = 0, list = node.declarations; i < list.length; i += 1)\r\n    {\r\n    var decl = list[i];\r\n\r\n    c(decl, st);\r\n  }\r\n};\r\nbase.VariableDeclarator = function (node, st, c) {\r\n  c(node.id, st, \"Pattern\");\r\n  if (node.init) { c(node.init, st, \"Expression\"); }\r\n};\r\n\r\nbase.Function = function (node, st, c) {\r\n  if (node.id) { c(node.id, st, \"Pattern\"); }\r\n  for (var i = 0, list = node.params; i < list.length; i += 1)\r\n    {\r\n    var param = list[i];\r\n\r\n    c(param, st, \"Pattern\");\r\n  }\r\n  c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\r\n};\r\n\r\nbase.Pattern = function (node, st, c) {\r\n  if (node.type === \"Identifier\")\r\n    { c(node, st, \"VariablePattern\"); }\r\n  else if (node.type === \"MemberExpression\")\r\n    { c(node, st, \"MemberPattern\"); }\r\n  else\r\n    { c(node, st); }\r\n};\r\nbase.VariablePattern = ignore;\r\nbase.MemberPattern = skipThrough;\r\nbase.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\r\nbase.ArrayPattern = function (node, st, c) {\r\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\r\n    var elt = list[i];\r\n\r\n    if (elt) { c(elt, st, \"Pattern\"); }\r\n  }\r\n};\r\nbase.ObjectPattern = function (node, st, c) {\r\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\r\n    var prop = list[i];\r\n\r\n    if (prop.type === \"Property\") {\r\n      if (prop.computed) { c(prop.key, st, \"Expression\"); }\r\n      c(prop.value, st, \"Pattern\");\r\n    } else if (prop.type === \"RestElement\") {\r\n      c(prop.argument, st, \"Pattern\");\r\n    }\r\n  }\r\n};\r\n\r\nbase.Expression = skipThrough;\r\nbase.ThisExpression = base.Super = base.MetaProperty = ignore;\r\nbase.ArrayExpression = function (node, st, c) {\r\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\r\n    var elt = list[i];\r\n\r\n    if (elt) { c(elt, st, \"Expression\"); }\r\n  }\r\n};\r\nbase.ObjectExpression = function (node, st, c) {\r\n  for (var i = 0, list = node.properties; i < list.length; i += 1)\r\n    {\r\n    var prop = list[i];\r\n\r\n    c(prop, st);\r\n  }\r\n};\r\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\r\nbase.SequenceExpression = function (node, st, c) {\r\n  for (var i = 0, list = node.expressions; i < list.length; i += 1)\r\n    {\r\n    var expr = list[i];\r\n\r\n    c(expr, st, \"Expression\");\r\n  }\r\n};\r\nbase.TemplateLiteral = function (node, st, c) {\r\n  for (var i = 0, list = node.quasis; i < list.length; i += 1)\r\n    {\r\n    var quasi = list[i];\r\n\r\n    c(quasi, st);\r\n  }\r\n\r\n  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\r\n    {\r\n    var expr = list$1[i$1];\r\n\r\n    c(expr, st, \"Expression\");\r\n  }\r\n};\r\nbase.TemplateElement = ignore;\r\nbase.UnaryExpression = base.UpdateExpression = function (node, st, c) {\r\n  c(node.argument, st, \"Expression\");\r\n};\r\nbase.BinaryExpression = base.LogicalExpression = function (node, st, c) {\r\n  c(node.left, st, \"Expression\");\r\n  c(node.right, st, \"Expression\");\r\n};\r\nbase.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\r\n  c(node.left, st, \"Pattern\");\r\n  c(node.right, st, \"Expression\");\r\n};\r\nbase.ConditionalExpression = function (node, st, c) {\r\n  c(node.test, st, \"Expression\");\r\n  c(node.consequent, st, \"Expression\");\r\n  c(node.alternate, st, \"Expression\");\r\n};\r\nbase.NewExpression = base.CallExpression = function (node, st, c) {\r\n  c(node.callee, st, \"Expression\");\r\n  if (node.arguments)\r\n    { for (var i = 0, list = node.arguments; i < list.length; i += 1)\r\n      {\r\n        var arg = list[i];\r\n\r\n        c(arg, st, \"Expression\");\r\n      } }\r\n};\r\nbase.MemberExpression = function (node, st, c) {\r\n  c(node.object, st, \"Expression\");\r\n  if (node.computed) { c(node.property, st, \"Expression\"); }\r\n};\r\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\r\n  if (node.declaration)\r\n    { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\r\n  if (node.source) { c(node.source, st, \"Expression\"); }\r\n};\r\nbase.ExportAllDeclaration = function (node, st, c) {\r\n  if (node.exported)\r\n    { c(node.exported, st); }\r\n  c(node.source, st, \"Expression\");\r\n};\r\nbase.ImportDeclaration = function (node, st, c) {\r\n  for (var i = 0, list = node.specifiers; i < list.length; i += 1)\r\n    {\r\n    var spec = list[i];\r\n\r\n    c(spec, st);\r\n  }\r\n  c(node.source, st, \"Expression\");\r\n};\r\nbase.ImportExpression = function (node, st, c) {\r\n  c(node.source, st, \"Expression\");\r\n};\r\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;\r\n\r\nbase.TaggedTemplateExpression = function (node, st, c) {\r\n  c(node.tag, st, \"Expression\");\r\n  c(node.quasi, st, \"Expression\");\r\n};\r\nbase.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\r\nbase.Class = function (node, st, c) {\r\n  if (node.id) { c(node.id, st, \"Pattern\"); }\r\n  if (node.superClass) { c(node.superClass, st, \"Expression\"); }\r\n  c(node.body, st);\r\n};\r\nbase.ClassBody = function (node, st, c) {\r\n  for (var i = 0, list = node.body; i < list.length; i += 1)\r\n    {\r\n    var elt = list[i];\r\n\r\n    c(elt, st);\r\n  }\r\n};\r\nbase.MethodDefinition = base.PropertyDefinition = base.Property = function (node, st, c) {\r\n  if (node.computed) { c(node.key, st, \"Expression\"); }\r\n  if (node.value) { c(node.value, st, \"Expression\"); }\r\n};\r\n\r\nexport { ancestor, base, findNodeAfter, findNodeAround, findNodeAt, findNodeBefore, full, fullAncestor, make, recursive, simple };\r\n"],
  "mappings": ";;;AAkBA,SAAS,OAAO,MAAM,UAAU,aAAa,OAAO,UAAU;AAC5D,MAAI,CAAC,aAAa;AAAE,kBAAc;AAAA,EAChC;AAAC,GAAC,SAAS,EAAEA,OAAM,IAAIC,WAAU;AACjC,QAAI,OAAOA,aAAYD,MAAK,MAAM,QAAQ,SAAS,IAAI;AACvD,gBAAY,IAAI,EAAEA,OAAM,IAAI,CAAC;AAC7B,QAAI,OAAO;AAAE,YAAMA,OAAM,EAAE;AAAA,IAAG;AAAA,EAChC,GAAG,MAAM,OAAO,QAAQ;AAC1B;AAKA,SAAS,SAAS,MAAM,UAAU,aAAa,OAAO,UAAU;AAC9D,MAAI,YAAY,CAAC;AACjB,MAAI,CAAC,aAAa;AAAE,kBAAc;AAAA,EAChC;AAAC,GAAC,SAAS,EAAEA,OAAM,IAAIC,WAAU;AACjC,QAAI,OAAOA,aAAYD,MAAK,MAAM,QAAQ,SAAS,IAAI;AACvD,QAAI,QAAQA,UAAS,UAAU,UAAU,SAAS,CAAC;AACnD,QAAI,OAAO;AAAE,gBAAU,KAAKA,KAAI;AAAA,IAAG;AACnC,gBAAY,IAAI,EAAEA,OAAM,IAAI,CAAC;AAC7B,QAAI,OAAO;AAAE,YAAMA,OAAM,MAAM,WAAW,SAAS;AAAA,IAAG;AACtD,QAAI,OAAO;AAAE,gBAAU,IAAI;AAAA,IAAG;AAAA,EAChC,GAAG,MAAM,OAAO,QAAQ;AAC1B;AAOA,SAAS,UAAU,MAAM,OAAO,OAAO,aAAa,UAAU;AAC5D,MAAI,UAAU,QAAQ,KAAK,OAAO,eAAe,MAAS,IAAI;AAC7D,GAAC,SAAS,EAAEA,OAAM,IAAIC,WAAU;AAC/B,YAAQA,aAAYD,MAAK,IAAI,EAAEA,OAAM,IAAI,CAAC;AAAA,EAC5C,GAAG,MAAM,OAAO,QAAQ;AAC1B;AAEA,SAAS,SAAS,MAAM;AACtB,MAAI,OAAO,SAAS,UAClB;AAAE,WAAO,SAAU,MAAM;AAAE,aAAO,SAAS;AAAA,IAAM;AAAA,EAAE,WAC5C,CAAC,MACR;AAAE,WAAO,WAAY;AAAE,aAAO;AAAA,IAAM;AAAA,EAAE,OAEtC;AAAE,WAAO;AAAA,EAAK;AAClB;AAEA,IAAI,QAAQ,SAASE,OAAM,MAAM,OAAO;AAAE,OAAK,OAAO;AAAM,OAAK,QAAQ;AAAO;AAGhF,SAAS,KAAK,MAAM,UAAU,aAAa,OAAO,UAAU;AAC1D,MAAI,CAAC,aAAa;AAAE,kBAAc;AAAA,EAAM;AACxC,MAAI;AACH,GAAC,SAAS,EAAEF,OAAM,IAAIC,WAAU;AAC/B,QAAI,OAAOA,aAAYD,MAAK;AAC5B,gBAAY,IAAI,EAAEA,OAAM,IAAI,CAAC;AAC7B,QAAI,SAASA,OAAM;AACjB,eAASA,OAAM,IAAI,IAAI;AACvB,aAAOA;AAAA,IACT;AAAA,EACF,GAAG,MAAM,OAAO,QAAQ;AAC1B;AAIA,SAAS,aAAa,MAAM,UAAU,aAAa,OAAO;AACxD,MAAI,CAAC,aAAa;AAAE,kBAAc;AAAA,EAAM;AACxC,MAAI,YAAY,CAAC,GAAG;AACnB,GAAC,SAAS,EAAEA,OAAM,IAAI,UAAU;AAC/B,QAAI,OAAO,YAAYA,MAAK;AAC5B,QAAI,QAAQA,UAAS,UAAU,UAAU,SAAS,CAAC;AACnD,QAAI,OAAO;AAAE,gBAAU,KAAKA,KAAI;AAAA,IAAG;AACnC,gBAAY,IAAI,EAAEA,OAAM,IAAI,CAAC;AAC7B,QAAI,SAASA,OAAM;AACjB,eAASA,OAAM,MAAM,WAAW,WAAW,IAAI;AAC/C,aAAOA;AAAA,IACT;AACA,QAAI,OAAO;AAAE,gBAAU,IAAI;AAAA,IAAG;AAAA,EAChC,GAAG,MAAM,KAAK;AAChB;AAKA,SAAS,WAAW,MAAM,OAAO,KAAK,MAAM,aAAa,OAAO;AAC9D,MAAI,CAAC,aAAa;AAAE,kBAAc;AAAA,EAAM;AACxC,SAAO,SAAS,IAAI;AACpB,MAAI;AACF,KAAC,SAAS,EAAEA,OAAM,IAAI,UAAU;AAC9B,UAAI,OAAO,YAAYA,MAAK;AAC5B,WAAK,SAAS,QAAQA,MAAK,SAAS,WAC/B,OAAO,QAAQA,MAAK,OAAO,MAC9B;AAAE,oBAAY,IAAI,EAAEA,OAAM,IAAI,CAAC;AAAA,MAAG;AACpC,WAAK,SAAS,QAAQA,MAAK,UAAU,WAChC,OAAO,QAAQA,MAAK,QAAQ,QAC7B,KAAK,MAAMA,KAAI,GACjB;AAAE,cAAM,IAAI,MAAMA,OAAM,EAAE;AAAA,MAAE;AAAA,IAChC,GAAG,MAAM,KAAK;AAAA,EAChB,SAAS,GAAG;AACV,QAAI,aAAa,OAAO;AAAE,aAAO;AAAA,IAAE;AACnC,UAAM;AAAA,EACR;AACF;AAIA,SAAS,eAAe,MAAM,KAAK,MAAM,aAAa,OAAO;AAC3D,SAAO,SAAS,IAAI;AACpB,MAAI,CAAC,aAAa;AAAE,kBAAc;AAAA,EAAM;AACxC,MAAI;AACF,KAAC,SAAS,EAAEA,OAAM,IAAI,UAAU;AAC9B,UAAI,OAAO,YAAYA,MAAK;AAC5B,UAAIA,MAAK,QAAQ,OAAOA,MAAK,MAAM,KAAK;AAAE;AAAA,MAAO;AACjD,kBAAY,IAAI,EAAEA,OAAM,IAAI,CAAC;AAC7B,UAAI,KAAK,MAAMA,KAAI,GAAG;AAAE,cAAM,IAAI,MAAMA,OAAM,EAAE;AAAA,MAAE;AAAA,IACpD,GAAG,MAAM,KAAK;AAAA,EAChB,SAAS,GAAG;AACV,QAAI,aAAa,OAAO;AAAE,aAAO;AAAA,IAAE;AACnC,UAAM;AAAA,EACR;AACF;AAGA,SAAS,cAAc,MAAM,KAAK,MAAM,aAAa,OAAO;AAC1D,SAAO,SAAS,IAAI;AACpB,MAAI,CAAC,aAAa;AAAE,kBAAc;AAAA,EAAM;AACxC,MAAI;AACF,KAAC,SAAS,EAAEA,OAAM,IAAI,UAAU;AAC9B,UAAIA,MAAK,MAAM,KAAK;AAAE;AAAA,MAAO;AAC7B,UAAI,OAAO,YAAYA,MAAK;AAC5B,UAAIA,MAAK,SAAS,OAAO,KAAK,MAAMA,KAAI,GAAG;AAAE,cAAM,IAAI,MAAMA,OAAM,EAAE;AAAA,MAAE;AACvE,kBAAY,IAAI,EAAEA,OAAM,IAAI,CAAC;AAAA,IAC/B,GAAG,MAAM,KAAK;AAAA,EAChB,SAAS,GAAG;AACV,QAAI,aAAa,OAAO;AAAE,aAAO;AAAA,IAAE;AACnC,UAAM;AAAA,EACR;AACF;AAGA,SAAS,eAAe,MAAM,KAAK,MAAM,aAAa,OAAO;AAC3D,SAAO,SAAS,IAAI;AACpB,MAAI,CAAC,aAAa;AAAE,kBAAc;AAAA,EAAM;AACxC,MAAI;AACH,GAAC,SAAS,EAAEA,OAAM,IAAI,UAAU;AAC/B,QAAIA,MAAK,QAAQ,KAAK;AAAE;AAAA,IAAO;AAC/B,QAAI,OAAO,YAAYA,MAAK;AAC5B,QAAIA,MAAK,OAAO,QAAQ,CAAC,OAAO,IAAI,KAAK,MAAMA,MAAK,QAAQ,KAAK,MAAMA,KAAI,GACzE;AAAE,YAAM,IAAI,MAAMA,OAAM,EAAE;AAAA,IAAG;AAC/B,gBAAY,IAAI,EAAEA,OAAM,IAAI,CAAC;AAAA,EAC/B,GAAG,MAAM,KAAK;AACd,SAAO;AACT;AAIA,SAAS,KAAK,OAAO,aAAa;AAChC,MAAI,UAAU,OAAO,OAAO,eAAe,IAAI;AAC/C,WAAS,QAAQ,OAAO;AAAE,YAAQ,IAAI,IAAI,MAAM,IAAI;AAAA,EAAG;AACvD,SAAO;AACT;AAEA,SAAS,YAAY,MAAM,IAAI,GAAG;AAAE,IAAE,MAAM,EAAE;AAAG;AACjD,SAAS,OAAO,OAAO,KAAK,IAAI;AAAC;AAIjC,IAAI,OAAO,CAAC;AAEZ,KAAK,UAAU,KAAK,iBAAiB,KAAK,cAAc,SAAU,MAAM,IAAI,GAAG;AAC7E,WAAS,IAAI,GAAG,OAAO,KAAK,MAAM,IAAI,KAAK,QAAQ,KAAK,GACtD;AACA,QAAI,OAAO,KAAK,CAAC;AAEjB,MAAE,MAAM,IAAI,WAAW;AAAA,EACzB;AACF;AACA,KAAK,YAAY;AACjB,KAAK,iBAAiB;AACtB,KAAK,sBAAsB,KAAK,0BAA0B,KAAK,kBAC7D,SAAU,MAAM,IAAI,GAAG;AAAE,SAAO,EAAE,KAAK,YAAY,IAAI,YAAY;AAAG;AACxE,KAAK,cAAc,SAAU,MAAM,IAAI,GAAG;AACxC,IAAE,KAAK,MAAM,IAAI,YAAY;AAC7B,IAAE,KAAK,YAAY,IAAI,WAAW;AAClC,MAAI,KAAK,WAAW;AAAE,MAAE,KAAK,WAAW,IAAI,WAAW;AAAA,EAAG;AAC5D;AACA,KAAK,mBAAmB,SAAU,MAAM,IAAI,GAAG;AAAE,SAAO,EAAE,KAAK,MAAM,IAAI,WAAW;AAAG;AACvF,KAAK,iBAAiB,KAAK,oBAAoB;AAC/C,KAAK,gBAAgB,SAAU,MAAM,IAAI,GAAG;AAC1C,IAAE,KAAK,QAAQ,IAAI,YAAY;AAC/B,IAAE,KAAK,MAAM,IAAI,WAAW;AAC9B;AACA,KAAK,kBAAkB,SAAU,MAAM,IAAI,GAAG;AAC5C,IAAE,KAAK,cAAc,IAAI,YAAY;AACrC,WAAS,MAAM,GAAG,SAAS,KAAK,OAAO,MAAM,OAAO,QAAQ,OAAO,GAAG;AACpE,QAAI,KAAK,OAAO,GAAG;AAEnB,QAAI,GAAG,MAAM;AAAE,QAAE,GAAG,MAAM,IAAI,YAAY;AAAA,IAAG;AAC7C,aAAS,IAAI,GAAG,OAAO,GAAG,YAAY,IAAI,KAAK,QAAQ,KAAK,GAC1D;AACA,UAAI,OAAO,KAAK,CAAC;AAEjB,QAAE,MAAM,IAAI,WAAW;AAAA,IACzB;AAAA,EACF;AACF;AACA,KAAK,aAAa,SAAU,MAAM,IAAI,GAAG;AACvC,MAAI,KAAK,MAAM;AAAE,MAAE,KAAK,MAAM,IAAI,YAAY;AAAA,EAAG;AACjD,WAAS,IAAI,GAAG,OAAO,KAAK,YAAY,IAAI,KAAK,QAAQ,KAAK,GAC5D;AACA,QAAI,OAAO,KAAK,CAAC;AAEjB,MAAE,MAAM,IAAI,WAAW;AAAA,EACzB;AACF;AACA,KAAK,kBAAkB,KAAK,kBAAkB,KAAK,kBAAkB,SAAU,MAAM,IAAI,GAAG;AAC1F,MAAI,KAAK,UAAU;AAAE,MAAE,KAAK,UAAU,IAAI,YAAY;AAAA,EAAG;AAC3D;AACA,KAAK,iBAAiB,KAAK,gBACzB,SAAU,MAAM,IAAI,GAAG;AAAE,SAAO,EAAE,KAAK,UAAU,IAAI,YAAY;AAAG;AACtE,KAAK,eAAe,SAAU,MAAM,IAAI,GAAG;AACzC,IAAE,KAAK,OAAO,IAAI,WAAW;AAC7B,MAAI,KAAK,SAAS;AAAE,MAAE,KAAK,SAAS,EAAE;AAAA,EAAG;AACzC,MAAI,KAAK,WAAW;AAAE,MAAE,KAAK,WAAW,IAAI,WAAW;AAAA,EAAG;AAC5D;AACA,KAAK,cAAc,SAAU,MAAM,IAAI,GAAG;AACxC,MAAI,KAAK,OAAO;AAAE,MAAE,KAAK,OAAO,IAAI,SAAS;AAAA,EAAG;AAChD,IAAE,KAAK,MAAM,IAAI,WAAW;AAC9B;AACA,KAAK,iBAAiB,KAAK,mBAAmB,SAAU,MAAM,IAAI,GAAG;AACnE,IAAE,KAAK,MAAM,IAAI,YAAY;AAC7B,IAAE,KAAK,MAAM,IAAI,WAAW;AAC9B;AACA,KAAK,eAAe,SAAU,MAAM,IAAI,GAAG;AACzC,MAAI,KAAK,MAAM;AAAE,MAAE,KAAK,MAAM,IAAI,SAAS;AAAA,EAAG;AAC9C,MAAI,KAAK,MAAM;AAAE,MAAE,KAAK,MAAM,IAAI,YAAY;AAAA,EAAG;AACjD,MAAI,KAAK,QAAQ;AAAE,MAAE,KAAK,QAAQ,IAAI,YAAY;AAAA,EAAG;AACrD,IAAE,KAAK,MAAM,IAAI,WAAW;AAC9B;AACA,KAAK,iBAAiB,KAAK,iBAAiB,SAAU,MAAM,IAAI,GAAG;AACjE,IAAE,KAAK,MAAM,IAAI,SAAS;AAC1B,IAAE,KAAK,OAAO,IAAI,YAAY;AAC9B,IAAE,KAAK,MAAM,IAAI,WAAW;AAC9B;AACA,KAAK,UAAU,SAAU,MAAM,IAAI,GAAG;AACpC,MAAI,KAAK,SAAS,uBAAuB;AAAE,MAAE,MAAM,EAAE;AAAA,EAAG,OACnD;AAAE,MAAE,MAAM,IAAI,YAAY;AAAA,EAAG;AACpC;AACA,KAAK,oBAAoB;AAEzB,KAAK,sBAAsB,SAAU,MAAM,IAAI,GAAG;AAAE,SAAO,EAAE,MAAM,IAAI,UAAU;AAAG;AACpF,KAAK,sBAAsB,SAAU,MAAM,IAAI,GAAG;AAChD,WAAS,IAAI,GAAG,OAAO,KAAK,cAAc,IAAI,KAAK,QAAQ,KAAK,GAC9D;AACA,QAAI,OAAO,KAAK,CAAC;AAEjB,MAAE,MAAM,EAAE;AAAA,EACZ;AACF;AACA,KAAK,qBAAqB,SAAU,MAAM,IAAI,GAAG;AAC/C,IAAE,KAAK,IAAI,IAAI,SAAS;AACxB,MAAI,KAAK,MAAM;AAAE,MAAE,KAAK,MAAM,IAAI,YAAY;AAAA,EAAG;AACnD;AAEA,KAAK,WAAW,SAAU,MAAM,IAAI,GAAG;AACrC,MAAI,KAAK,IAAI;AAAE,MAAE,KAAK,IAAI,IAAI,SAAS;AAAA,EAAG;AAC1C,WAAS,IAAI,GAAG,OAAO,KAAK,QAAQ,IAAI,KAAK,QAAQ,KAAK,GACxD;AACA,QAAI,QAAQ,KAAK,CAAC;AAElB,MAAE,OAAO,IAAI,SAAS;AAAA,EACxB;AACA,IAAE,KAAK,MAAM,IAAI,KAAK,aAAa,eAAe,WAAW;AAC/D;AAEA,KAAK,UAAU,SAAU,MAAM,IAAI,GAAG;AACpC,MAAI,KAAK,SAAS,cAChB;AAAE,MAAE,MAAM,IAAI,iBAAiB;AAAA,EAAG,WAC3B,KAAK,SAAS,oBACrB;AAAE,MAAE,MAAM,IAAI,eAAe;AAAA,EAAG,OAEhC;AAAE,MAAE,MAAM,EAAE;AAAA,EAAG;AACnB;AACA,KAAK,kBAAkB;AACvB,KAAK,gBAAgB;AACrB,KAAK,cAAc,SAAU,MAAM,IAAI,GAAG;AAAE,SAAO,EAAE,KAAK,UAAU,IAAI,SAAS;AAAG;AACpF,KAAK,eAAe,SAAU,MAAM,IAAI,GAAG;AACzC,WAAS,IAAI,GAAG,OAAO,KAAK,UAAU,IAAI,KAAK,QAAQ,KAAK,GAAG;AAC7D,QAAI,MAAM,KAAK,CAAC;AAEhB,QAAI,KAAK;AAAE,QAAE,KAAK,IAAI,SAAS;AAAA,IAAG;AAAA,EACpC;AACF;AACA,KAAK,gBAAgB,SAAU,MAAM,IAAI,GAAG;AAC1C,WAAS,IAAI,GAAG,OAAO,KAAK,YAAY,IAAI,KAAK,QAAQ,KAAK,GAAG;AAC/D,QAAI,OAAO,KAAK,CAAC;AAEjB,QAAI,KAAK,SAAS,YAAY;AAC5B,UAAI,KAAK,UAAU;AAAE,UAAE,KAAK,KAAK,IAAI,YAAY;AAAA,MAAG;AACpD,QAAE,KAAK,OAAO,IAAI,SAAS;AAAA,IAC7B,WAAW,KAAK,SAAS,eAAe;AACtC,QAAE,KAAK,UAAU,IAAI,SAAS;AAAA,IAChC;AAAA,EACF;AACF;AAEA,KAAK,aAAa;AAClB,KAAK,iBAAiB,KAAK,QAAQ,KAAK,eAAe;AACvD,KAAK,kBAAkB,SAAU,MAAM,IAAI,GAAG;AAC5C,WAAS,IAAI,GAAG,OAAO,KAAK,UAAU,IAAI,KAAK,QAAQ,KAAK,GAAG;AAC7D,QAAI,MAAM,KAAK,CAAC;AAEhB,QAAI,KAAK;AAAE,QAAE,KAAK,IAAI,YAAY;AAAA,IAAG;AAAA,EACvC;AACF;AACA,KAAK,mBAAmB,SAAU,MAAM,IAAI,GAAG;AAC7C,WAAS,IAAI,GAAG,OAAO,KAAK,YAAY,IAAI,KAAK,QAAQ,KAAK,GAC5D;AACA,QAAI,OAAO,KAAK,CAAC;AAEjB,MAAE,MAAM,EAAE;AAAA,EACZ;AACF;AACA,KAAK,qBAAqB,KAAK,0BAA0B,KAAK;AAC9D,KAAK,qBAAqB,SAAU,MAAM,IAAI,GAAG;AAC/C,WAAS,IAAI,GAAG,OAAO,KAAK,aAAa,IAAI,KAAK,QAAQ,KAAK,GAC7D;AACA,QAAI,OAAO,KAAK,CAAC;AAEjB,MAAE,MAAM,IAAI,YAAY;AAAA,EAC1B;AACF;AACA,KAAK,kBAAkB,SAAU,MAAM,IAAI,GAAG;AAC5C,WAAS,IAAI,GAAG,OAAO,KAAK,QAAQ,IAAI,KAAK,QAAQ,KAAK,GACxD;AACA,QAAI,QAAQ,KAAK,CAAC;AAElB,MAAE,OAAO,EAAE;AAAA,EACb;AAEA,WAAS,MAAM,GAAG,SAAS,KAAK,aAAa,MAAM,OAAO,QAAQ,OAAO,GACvE;AACA,QAAI,OAAO,OAAO,GAAG;AAErB,MAAE,MAAM,IAAI,YAAY;AAAA,EAC1B;AACF;AACA,KAAK,kBAAkB;AACvB,KAAK,kBAAkB,KAAK,mBAAmB,SAAU,MAAM,IAAI,GAAG;AACpE,IAAE,KAAK,UAAU,IAAI,YAAY;AACnC;AACA,KAAK,mBAAmB,KAAK,oBAAoB,SAAU,MAAM,IAAI,GAAG;AACtE,IAAE,KAAK,MAAM,IAAI,YAAY;AAC7B,IAAE,KAAK,OAAO,IAAI,YAAY;AAChC;AACA,KAAK,uBAAuB,KAAK,oBAAoB,SAAU,MAAM,IAAI,GAAG;AAC1E,IAAE,KAAK,MAAM,IAAI,SAAS;AAC1B,IAAE,KAAK,OAAO,IAAI,YAAY;AAChC;AACA,KAAK,wBAAwB,SAAU,MAAM,IAAI,GAAG;AAClD,IAAE,KAAK,MAAM,IAAI,YAAY;AAC7B,IAAE,KAAK,YAAY,IAAI,YAAY;AACnC,IAAE,KAAK,WAAW,IAAI,YAAY;AACpC;AACA,KAAK,gBAAgB,KAAK,iBAAiB,SAAU,MAAM,IAAI,GAAG;AAChE,IAAE,KAAK,QAAQ,IAAI,YAAY;AAC/B,MAAI,KAAK,WACP;AAAE,aAAS,IAAI,GAAG,OAAO,KAAK,WAAW,IAAI,KAAK,QAAQ,KAAK,GAC7D;AACE,UAAI,MAAM,KAAK,CAAC;AAEhB,QAAE,KAAK,IAAI,YAAY;AAAA,IACzB;AAAA,EAAE;AACR;AACA,KAAK,mBAAmB,SAAU,MAAM,IAAI,GAAG;AAC7C,IAAE,KAAK,QAAQ,IAAI,YAAY;AAC/B,MAAI,KAAK,UAAU;AAAE,MAAE,KAAK,UAAU,IAAI,YAAY;AAAA,EAAG;AAC3D;AACA,KAAK,yBAAyB,KAAK,2BAA2B,SAAU,MAAM,IAAI,GAAG;AACnF,MAAI,KAAK,aACP;AAAE,MAAE,KAAK,aAAa,IAAI,KAAK,SAAS,4BAA4B,KAAK,YAAY,KAAK,cAAc,YAAY;AAAA,EAAG;AACzH,MAAI,KAAK,QAAQ;AAAE,MAAE,KAAK,QAAQ,IAAI,YAAY;AAAA,EAAG;AACvD;AACA,KAAK,uBAAuB,SAAU,MAAM,IAAI,GAAG;AACjD,MAAI,KAAK,UACP;AAAE,MAAE,KAAK,UAAU,EAAE;AAAA,EAAG;AAC1B,IAAE,KAAK,QAAQ,IAAI,YAAY;AACjC;AACA,KAAK,oBAAoB,SAAU,MAAM,IAAI,GAAG;AAC9C,WAAS,IAAI,GAAG,OAAO,KAAK,YAAY,IAAI,KAAK,QAAQ,KAAK,GAC5D;AACA,QAAI,OAAO,KAAK,CAAC;AAEjB,MAAE,MAAM,EAAE;AAAA,EACZ;AACA,IAAE,KAAK,QAAQ,IAAI,YAAY;AACjC;AACA,KAAK,mBAAmB,SAAU,MAAM,IAAI,GAAG;AAC7C,IAAE,KAAK,QAAQ,IAAI,YAAY;AACjC;AACA,KAAK,kBAAkB,KAAK,yBAAyB,KAAK,2BAA2B,KAAK,aAAa,KAAK,oBAAoB,KAAK,UAAU;AAE/I,KAAK,2BAA2B,SAAU,MAAM,IAAI,GAAG;AACrD,IAAE,KAAK,KAAK,IAAI,YAAY;AAC5B,IAAE,KAAK,OAAO,IAAI,YAAY;AAChC;AACA,KAAK,mBAAmB,KAAK,kBAAkB,SAAU,MAAM,IAAI,GAAG;AAAE,SAAO,EAAE,MAAM,IAAI,OAAO;AAAG;AACrG,KAAK,QAAQ,SAAU,MAAM,IAAI,GAAG;AAClC,MAAI,KAAK,IAAI;AAAE,MAAE,KAAK,IAAI,IAAI,SAAS;AAAA,EAAG;AAC1C,MAAI,KAAK,YAAY;AAAE,MAAE,KAAK,YAAY,IAAI,YAAY;AAAA,EAAG;AAC7D,IAAE,KAAK,MAAM,EAAE;AACjB;AACA,KAAK,YAAY,SAAU,MAAM,IAAI,GAAG;AACtC,WAAS,IAAI,GAAG,OAAO,KAAK,MAAM,IAAI,KAAK,QAAQ,KAAK,GACtD;AACA,QAAI,MAAM,KAAK,CAAC;AAEhB,MAAE,KAAK,EAAE;AAAA,EACX;AACF;AACA,KAAK,mBAAmB,KAAK,qBAAqB,KAAK,WAAW,SAAU,MAAM,IAAI,GAAG;AACvF,MAAI,KAAK,UAAU;AAAE,MAAE,KAAK,KAAK,IAAI,YAAY;AAAA,EAAG;AACpD,MAAI,KAAK,OAAO;AAAE,MAAE,KAAK,OAAO,IAAI,YAAY;AAAA,EAAG;AACrD;",
  "names": ["node", "override", "Found"]
}
